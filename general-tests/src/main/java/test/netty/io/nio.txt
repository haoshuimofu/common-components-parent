import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.channels.SelectionKey;
import java.util.Iterator;

public class NIOServer {
 private static final int BUF_SIZE =1024;
 private static final int PORT =8888;
 private static final int TIMEOUT =3000;

 public static void main(String[] args) {
 selector();
 }

 public static void selector() {
 Selector selector = null;
 ServerSocketChannel serverSocketChannel = null;
 try {
 selector = Selector.open();
 serverSocketChannel = ServerSocketChannel.open();
 serverSocketChannel.socket().bind(new InetSocketAddress(PORT));
 serverSocketChannel.configureBlocking(false);
 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
 while (true) {
 if (selector.select(TIMEOUT) ==0) {
 System.out.println("等待连接超时。");
 continue;
 }
 Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
 while (iterator.hasNext()) {
 SelectionKey key = iterator.next();
 if (key.isAcceptable()) {
 handleAccept(key);
 }
 if (key.isReadable()) {
 handleRead(key);
 }
 if (key.isWritable() && key.isValid()) {
 handleWrite(key);
 }
 if (key.isConnectable()) {
 System.out.println("isConnectable = true");
 }
 iterator.remove();
 }
 }
 } catch (IOException e) {
 e.printStackTrace();
 } finally {
 try {
 if (selector != null) {
 selector.close();
 }
 if (serverSocketChannel != null) {
 serverSocketChannel.close();
 }
 } catch (IOException e) {
 e.printStackTrace();
 }
 }
 }

 private static void handleAccept(SelectionKey key) throws IOException {
 ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
 SocketChannel socketChannel = serverSocketChannel.accept();
 socketChannel.configureBlocking(false);
 socketChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocateDirect(BUF_SIZE));
 }

 private static void handleRead(SelectionKey key) throws IOException {
 SocketChannel socketChannel = (SocketChannel) key.channel();
 ByteBuffer buf = (ByteBuffer) key.attachment();
 long bytesRead = socketChannel.read(buf);
 while (bytesRead >0) {
 buf.flip();
 while (buf.hasRemaining()) {
 System.out.print((char) buf.get());
 }
 System.out.println();
 buf.clear();
 bytesRead = socketChannel.read(buf);
 }
 if (bytesRead == -1) {
 socketChannel.close();
 }
 }

 private static void handleWrite(SelectionKey key) throws IOException {
 ByteBuffer buf = (ByteBuffer) key.attachment();
 buf.flip();
 SocketChannel socketChannel = (SocketChannel) key.channel();
 while (buf.hasRemaining()) {
 socketChannel.write(buf);
 }
 buf.compact();
 }
}
